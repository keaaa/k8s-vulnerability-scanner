package main

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"sync"
	"time"
)

// SQLClient used to perform sql queries
type SQLClient struct {
	Server   string
	Port     int
	Database string
	UserID   string
	Password string
	db       *sql.DB
}

// NewSQLClient create sqlclient and setup the db connection
func NewSQLClient(server, database string, port int, userID, password string) SQLClient {
	sqlClient := SQLClient{
		Server:   server,
		Database: database,
		Port:     port,
		UserID:   userID,
		Password: password,
	}
	sqlClient.db = sqlClient.setupDBConnection()
	return sqlClient
}

func (sqlClient SQLClient) GetLatestImageSummaries() ([]ImageSummary, error) {
	tsql := `
SELECT imgs.id,
	   imgs.run_id,
	   runs.measured_time_utc,
	   COALESCE(imgs.target, ''),
       imgs.name,
       imgs.critical_severities,
       imgs.high_severities,
       imgs.medium_severities,
       imgs.low_severities,
       imgs.unknown_severities
FROM [vulnerability].[images] imgs
JOIN [vulnerability].[runs] runs ON imgs.run_id = runs.id
WHERE run_id=(SELECT TOP (1) id
     FROM [vulnerability].[runs]
     ORDER BY measured_time_utc DESC)`

	return sqlClient.loadImageSummaries(tsql)
}

// CreateNewRun creates a new run and returns the run id
func (sqlClient SQLClient) CreateNewRun(measureTime time.Time) (int, error) {
	tsql := `
INSERT INTO vulnerability.runs (measured_time_utc)
VALUES (@measuredTimeUTC);

SELECT convert(bigint, SCOPE_IDENTITY());`
	return sqlClient.execSQL(tsql,
		sql.Named("measuredTimeUTC", measureTime))
}

// GetTargetByImageName get vulnerabilities by image name
func (sqlClient SQLClient) GetTargetByImageName(imageName string) (*Target, error) {
	tsql := `
	SELECT imgs.id,
		   imgs.run_id,
		   runs.measured_time_utc,
		   COALESCE(imgs.target, ''),
		   imgs.name,
		   imgs.critical_severities,
		   imgs.high_severities,
		   imgs.medium_severities,
		   imgs.low_severities,
		   imgs.unknown_severities
	FROM [vulnerability].[images] imgs
	JOIN [vulnerability].[runs] runs ON imgs.run_id = runs.id
	WHERE imgs.name=@imageName AND 
		 run_id=(SELECT TOP (1) id
		 FROM [vulnerability].[runs]
		 ORDER BY measured_time_utc DESC)`

	latestImageSummary, err := sqlClient.loadImageSummaries(tsql, sql.Named("imageName", imageName))
	if err != nil {
		return nil, err
	}
	if len(latestImageSummary) == 0 {
		return nil, fmt.Errorf("vulnerabilities for image not found")
	}
	if len(latestImageSummary) > 1 {
		return nil, fmt.Errorf("several image summaries found for latest run")
	}
	imageSummary := latestImageSummary[0]
	vulnerabilities, err := sqlClient.getVulnerabilitiesByImage(imageSummary.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerabilities %v", err)
	}

	target := Target{
		Target:          imageSummary.Target,
		Image:           imageSummary.Name,
		MeasuredTime:    &imageSummary.MeasuredTimeUTC,
		Vulnerabilities: vulnerabilities,
	}
	target.CriticalSeverity = target.countBySeverity(Critical)
	target.HighSeverity = target.countBySeverity(High)
	target.MediumSeverity = target.countBySeverity(Medium)
	target.LowSeverity = target.countBySeverity(Low)
	target.UnknownSeverity = target.countBySeverity(Unknown)

	return &target, nil
}

func (sqlClient SQLClient) getVulnerabilitiesByImage(imageID int) ([]Vulnerability, error) {
	tsql := `
SELECT cve_vulnerability_id, pkg_name, installed_version, layer_id, title, description, severity
FROM [vulnerability].[vulnerabilties] vul
WHERE vul.image_id=@imageID`
	vulnerabilities := []Vulnerability{}
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return nil, err
	}

	// Execute query
	rows, err := sqlClient.db.QueryContext(ctx, tsql, sql.Named("imageID", imageID))
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	// Iterate through the result set.
	for rows.Next() {
		var cveID, pkgName, installedVersion, layerID, title, description, severity string

		// Get values from row.
		err := rows.Scan(&cveID,
			&pkgName,
			&installedVersion,
			&layerID,
			&title,
			&description,
			&severity,
		)
		if err != nil {
			return nil, err
		}

		vul := Vulnerability{
			VulnerabilityID:  cveID,
			PkgName:          pkgName,
			InstalledVersion: installedVersion,
			LayerID:          layerID,
			Title:            title,
			Description:      description,
			Severity:         Severity(severity),
			References:       []string{},
		}
		vulnerabilities = append(vulnerabilities, vul)
	}

	return vulnerabilities, nil

}

// SaveTarget saves a target linked to runID in db
func (sqlClient SQLClient) SaveTarget(runID int, target *Target) error {
	tsql := `
INSERT INTO vulnerability.images (name, target, run_id, critical_severities, high_severities, medium_severities, low_severities, unknown_severities)
VALUES (@imageName, @target, @runID, @criticalSeverities, @highSeverities, @mediumSeverities, @lowSeverities, @unknownSeverities);

SELECT convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save image")
	imageID, err := sqlClient.execSQL(tsql,
		sql.Named("imageName", target.Image),
		sql.Named("target", target.Target),
		sql.Named("runID", runID),
		sql.Named("criticalSeverities", target.countBySeverity(Critical)),
		sql.Named("highSeverities", target.countBySeverity(High)),
		sql.Named("mediumSeverities", target.countBySeverity(Medium)),
		sql.Named("lowSeverities", target.countBySeverity(Low)),
		sql.Named("unknownSeverities", target.countBySeverity(Unknown)))
	if err != nil {
		return err
	}

	var wg sync.WaitGroup
	var saveVulErr error
	var savePodErr error
	wg.Add(2)
	go func() {
		saveVulErr = sqlClient.saveVulnerabilities(target.Target, imageID, target.Vulnerabilities)
		wg.Done()
	}()

	go func() {
		savePodErr = sqlClient.savePods(imageID, target.Pods)
		wg.Done()
	}()
	wg.Wait()

	if savePodErr != nil {
		return fmt.Errorf("Failed to save pod %v", savePodErr)
	}
	if saveVulErr != nil {
		return fmt.Errorf("Failed to save vulnerabilities %v", saveVulErr)
	}

	return nil
}

func (sqlClient SQLClient) loadImageSummaries(tsql string, args ...interface{}) ([]ImageSummary, error) {
	images := []ImageSummary{}
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return nil, err
	}

	// Execute query
	rows, err := sqlClient.db.QueryContext(ctx, tsql, args...)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	// Iterate through the result set.
	for rows.Next() {
		var measuredTimeUTC time.Time
		var imageID, runID, criticalSeverities, highSeverities, mediumSeverities, lowSeverities, unknownSeverities int
		var imageName, targetName string

		// Get values from row.
		err := rows.Scan(&imageID,
			&runID,
			&measuredTimeUTC,
			&targetName,
			&imageName,
			&criticalSeverities,
			&highSeverities,
			&mediumSeverities,
			&lowSeverities,
			&unknownSeverities,
		)
		if err != nil {
			return nil, err
		}

		image := ImageSummary{
			ID:               imageID,
			Name:             imageName,
			Target:           targetName,
			RunID:            runID,
			MeasuredTimeUTC:  measuredTimeUTC,
			CriticalSeverity: criticalSeverities,
			HighSeverity:     highSeverities,
			MediumSeverity:   mediumSeverities,
			LowSeverity:      lowSeverities,
			UnknownSeverity:  unknownSeverities,
		}
		images = append(images, image)
	}

	return images, nil
}

func (sqlClient SQLClient) savePods(imageID int, pods []Pod) error {
	tsql := `
INSERT INTO vulnerability.pods (name, namespace, image_id)
VALUES (@name, @namespace, @imageID);

SELECT convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save pods")
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, pod := range pods {
		row := stmt.QueryRowContext(ctx,
			sql.Named("name", pod.Name),
			sql.Named("namespace", pod.Namespace),
			sql.Named("imageID", imageID))

		var newID int
		err = row.Scan(&newID)
		if err != nil {
			return fmt.Errorf("Failed to insert pod %v", err)
		}
	}
	return nil
}

func (sqlClient SQLClient) saveVulnerabilities(target string, imageID int, vulnerabilities []Vulnerability) error {
	tsql := `
INSERT INTO vulnerability.vulnerabilties (target, cve_vulnerability_id, pkg_name, installed_version, layer_id, title, description, severity, image_id)
VALUES (@target, @cveVulID, @pkgName, @installedVersion, @layerID, @title, @description, @severity, @imageID);

SELECT convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save vulnerabilities")
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, vul := range vulnerabilities {
		row := stmt.QueryRowContext(ctx, sql.Named("target", target),
			sql.Named("cveVulID", vul.VulnerabilityID),
			sql.Named("pkgName", vul.PkgName),
			sql.Named("installedVersion", vul.InstalledVersion),
			sql.Named("layerID", vul.LayerID),
			sql.Named("title", vul.Title),
			sql.Named("description", vul.Description),
			sql.Named("severity", vul.Severity),
			sql.Named("imageID", imageID))

		var newID int
		err = row.Scan(&newID)

		if err != nil {
			return fmt.Errorf("Failed to insert vulnerability %v", err)
		}
	}
	return nil
}

// Close the underlying db connection
func (sqlClient SQLClient) Close() {
	sqlClient.db.Close()
}

// SetupDBConnection sets up db connection
func (sqlClient SQLClient) setupDBConnection() *sql.DB {
	// Build connection string
	connString := fmt.Sprintf("server=%s;user id=%s;password=%s;port=%d;database=%s;",
		sqlClient.Server, sqlClient.UserID, sqlClient.Password, sqlClient.Port, sqlClient.Database)

	var err error

	// Create connection pool
	db, err := sql.Open("sqlserver", connString)
	if err != nil {
		log.Fatal("Error creating connection pool: ", err.Error())
	}
	ctx := context.Background()
	err = db.PingContext(ctx)
	if err != nil {
		log.Fatal(err.Error())
	}
	fmt.Printf("Connected!\n")
	return db
}

func (sqlClient SQLClient) execSQL(tsql string, args ...interface{}) (int, error) {
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return -1, err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return -1, err
	}
	defer stmt.Close()

	row := stmt.QueryRowContext(ctx, args...)
	var newID int
	err = row.Scan(&newID)
	if err != nil {
		return -1, err
	}

	return newID, nil
}

func (sqlClient SQLClient) verifyConnection() (context.Context, error) {
	ctx := context.Background()
	var err error

	if sqlClient.db == nil {
		err = errors.New("CreateRun: db is null")
		return ctx, err
	}

	// Check if database is alive.
	err = sqlClient.db.PingContext(ctx)
	if err != nil {
		return ctx, err
	}
	return ctx, nil
}
