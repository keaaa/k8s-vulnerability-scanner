package main

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"sync"
	"time"
)

// SQLClient used to perform sql queries
type SQLClient struct {
	Server   string
	Port     int
	Database string
	UserID   string
	Password string
	db       *sql.DB
}

// NewSQLClient create sqlclient and setup the db connection
func NewSQLClient(server, database string, port int, userID, password string) SQLClient {
	sqlClient := SQLClient{
		Server:   server,
		Database: database,
		Port:     port,
		UserID:   userID,
		Password: password,
	}
	sqlClient.db = sqlClient.setupDBConnection()
	return sqlClient
}

// func (sqlClient SQLClient) getLatestImageSummaries() ([]Target, error) {
// 	targets := []Target{}
// 	ctx, err := sqlClient.verifyConnection()
// 	if err != nil {
// 		return nil, err
// 	}

// 	tsql := "SELECT ;"

// 	// Execute query
// 	rows, err := sqlClient.db.QueryContext(ctx, tsql)
// 	if err != nil {
// 		return nil, err
// 	}

// 	defer rows.Close()

// 	// Iterate through the result set.
// 	for rows.Next() {
// 		var measuredTimeUTC time.Time
// 		var runID, id int64
// 		var clusterCPUMillicores, clusterMemoryMegaBytes, cpuMillicores, memoryMegaBytes, replicas int
// 		var wbs, application, environment, component string
// 		var run models.Run

// 		// Get values from row.
// 		err := rows.Scan(&runID,
// 			&measuredTimeUTC,
// 			&clusterCPUMillicores,
// 			&clusterMemoryMegaBytes,
// 			&id,
// 			&wbs,
// 			&application,
// 			&environment,
// 			&component,
// 			&cpuMillicores,
// 			&memoryMegaBytes,
// 			&replicas,
// 		)
// 		if err != nil {
// 			return nil, err
// 		}

// 		resource := models.RequiredResources{
// 			ID:              id,
// 			WBS:             wbs,
// 			Application:     application,
// 			Environment:     environment,
// 			Component:       component,
// 			CPUMillicore:    cpuMillicores,
// 			MemoryMegaBytes: memoryMegaBytes,
// 			Replicas:        replicas,
// 		}

// 		if run = runs[runID]; run.ID == 0 {
// 			resources := []models.RequiredResources{resource}
// 			runsResources[runID] = &resources
// 			run = models.Run{
// 				ID:                    runID,
// 				MeasuredTimeUTC:       measuredTimeUTC,
// 				ClusterCPUMillicore:   clusterCPUMillicores,
// 				ClusterMemoryMegaByte: clusterMemoryMegaBytes,
// 			}
// 			runs[runID] = run
// 		} else {
// 			resources := *runsResources[runID]
// 			resources = append(resources, resource)
// 			runsResources[runID] = &resources
// 		}
// 	}

// 	runsAsArray := []models.Run{}
// 	for key, val := range runs {
// 		val.Resources = *runsResources[key]
// 		runsAsArray = append(runsAsArray, val)
// 	}

// 	return runsAsArray, nil
// }

// CreateNewRun creates a new run and returns the run id
func (sqlClient SQLClient) CreateNewRun(measureTime time.Time) (int, error) {
	tsql := `INSERT INTO vulnerability.runs (measured_time_utc) 
	VALUES (@measuredTimeUTC); select convert(bigint, SCOPE_IDENTITY());`
	return sqlClient.execSQL(tsql,
		sql.Named("measuredTimeUTC", measureTime))
}

func (sqlClient SQLClient) saveTarget(runID int, target *Target) error {
	tsql := `INSERT INTO vulnerability.images (name, run_id, critical_severities, high_severities, medium_severities, low_severities, unknown_severities) 
	VALUES (@imageName, @runID, @criticalSeverities, @highSeverities, @mediumSeverities, @lowSeverities, @unknownSeverities); select convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save image")
	imageID, err := sqlClient.execSQL(tsql,
		sql.Named("imageName", target.Image),
		sql.Named("runID", runID),
		sql.Named("criticalSeverities", target.countBySeverity(Critical)),
		sql.Named("highSeverities", target.countBySeverity(High)),
		sql.Named("mediumSeverities", target.countBySeverity(Medium)),
		sql.Named("lowSeverities", target.countBySeverity(Low)),
		sql.Named("unknownSeverities", target.countBySeverity(Unknown)))
	if err != nil {
		return err
	}

	var wg sync.WaitGroup
	var saveVulErr error
	var savePodErr error
	wg.Add(2)
	go func() {
		saveVulErr = sqlClient.saveVulnerabilities(target.Target, imageID, target.Vulnerabilities)
		wg.Done()
	}()

	go func() {
		savePodErr = sqlClient.savePods(imageID, target.Pods)
		wg.Done()
	}()
	wg.Wait()

	if savePodErr != nil {
		return fmt.Errorf("Failed to save pod %v", savePodErr)
	}
	if saveVulErr != nil {
		return fmt.Errorf("Failed to save vulnerabilities %v", saveVulErr)
	}

	return nil
}

func (sqlClient SQLClient) savePods(imageID int, pods []Pod) error {
	tsql := `INSERT INTO vulnerability.pods (name, namespace, image_id) 
	VALUES (@name, @namespace, @imageID);select convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save pods")
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, pod := range pods {
		row := stmt.QueryRowContext(ctx,
			sql.Named("name", pod.Name),
			sql.Named("namespace", pod.Namespace),
			sql.Named("imageID", imageID))

		var newID int
		err = row.Scan(&newID)
		if err != nil {
			return fmt.Errorf("Failed to insert pod %v", err)
		}
	}
	return nil
}

func (sqlClient SQLClient) saveVulnerabilities(target string, imageID int, vulnerabilities []Vulnerability) error {
	tsql := `INSERT INTO vulnerability.vulnerabilties (target, cve_vulnerability_id, pkg_name, installed_version, layer_id, title, description, severity, image_id) 
	VALUES (@target, @cveVulID, @pkgName, @installedVersion, @layerID, @title, @description, @severity, @imageID); select convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save vulnerabilities")
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, vul := range vulnerabilities {
		row := stmt.QueryRowContext(ctx, sql.Named("target", target),
			sql.Named("cveVulID", vul.VulnerabilityID),
			sql.Named("pkgName", vul.PkgName),
			sql.Named("installedVersion", vul.InstalledVersion),
			sql.Named("layerID", vul.LayerID),
			sql.Named("title", vul.Title),
			sql.Named("description", vul.Description),
			sql.Named("severity", vul.Severity),
			sql.Named("imageID", imageID))

		var newID int
		err = row.Scan(&newID)

		if err != nil {
			return fmt.Errorf("Failed to insert vulnerability %v", err)
		}
	}
	return nil
}

// Close the underlying db connection
func (sqlClient SQLClient) Close() {
	sqlClient.db.Close()
}

// SetupDBConnection sets up db connection
func (sqlClient SQLClient) setupDBConnection() *sql.DB {
	// Build connection string
	connString := fmt.Sprintf("server=%s;user id=%s;password=%s;port=%d;database=%s;",
		sqlClient.Server, sqlClient.UserID, sqlClient.Password, sqlClient.Port, sqlClient.Database)

	var err error

	// Create connection pool
	db, err := sql.Open("sqlserver", connString)
	if err != nil {
		log.Fatal("Error creating connection pool: ", err.Error())
	}
	ctx := context.Background()
	err = db.PingContext(ctx)
	if err != nil {
		log.Fatal(err.Error())
	}
	fmt.Printf("Connected!\n")
	return db
}

func (sqlClient SQLClient) execSQL(tsql string, args ...interface{}) (int, error) {
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return -1, err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return -1, err
	}
	defer stmt.Close()

	row := stmt.QueryRowContext(ctx, args...)
	var newID int
	err = row.Scan(&newID)
	if err != nil {
		return -1, err
	}

	return newID, nil
}

func (sqlClient SQLClient) verifyConnection() (context.Context, error) {
	ctx := context.Background()
	var err error

	if sqlClient.db == nil {
		err = errors.New("CreateRun: db is null")
		return ctx, err
	}

	// Check if database is alive.
	err = sqlClient.db.PingContext(ctx)
	if err != nil {
		return ctx, err
	}
	return ctx, nil
}
