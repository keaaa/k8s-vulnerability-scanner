package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"sort"
	"strconv"
	"time"

	"github.com/gorilla/mux"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

// GetLatestVulnerabilities get a summary of active vulnerabilities
func GetLatestVulnerabilities(sqlClient SQLClient, w http.ResponseWriter, r *http.Request) {
	log.Println("get latest vulnerabilities")
	images, err := sqlClient.GetLatestImageSummaries()
	if err != nil {
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	respondWithJSON(w, http.StatusOK, images)
}

// GetVulnerabilitiesByImageName gets vulnerability details by image name
func GetVulnerabilitiesByImageName(sqlClient SQLClient, w http.ResponseWriter, r *http.Request) {
	log.Println("getting vulnerability details by image name")

	imageName := r.URL.Query().Get("image")
	image, err := sqlClient.GetLastImageRunByImageName(imageName)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	respondWithJSON(w, http.StatusOK, image)
}

// SaveVulnerabilities saves vulnerability - JSON format based on https://github.com/aquasecurity/trivy#save-the-results-as-json
func SaveVulnerabilities(sqlClient SQLClient, w http.ResponseWriter, r *http.Request) {
	log.Println("saving vulnerabilities")

	vars := mux.Vars(r)
	imageName := r.URL.Query().Get("image")
	runID, err := strconv.Atoi(vars["id"])
	if err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid run id")
		return
	}
	if imageName == "" {
		respondWithError(w, http.StatusBadRequest, "Image name is required")
		return
	}

	image, err := getImage(runID, imageName, r)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}

	err = sqlClient.SaveTarget(runID, image)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, err.Error())
		return
	}
	respondWithJSON(w, http.StatusOK, image)
}

// NewRunHandler Starts a new vulnerability scan of all images used by active pods
func NewRunHandler(sqlClient SQLClient, w http.ResponseWriter, r *http.Request) error {
	log.Println("creating new run")

	clientset := getClientSet()
	images, err := getUniqueImagesFromPods(clientset)
	fmt.Printf("There are %d unique images in the cluster\n", len(images))
	if err != nil {
		fmt.Printf("Error %v", err)
		return err
	}

	measureTime := time.Now().UTC()
	runID, err := sqlClient.CreateNewRun(measureTime)
	if err != nil {
		return err
	}

	for _, image := range images {
		err, jobName := scanImage(clientset, int(runID), image)
		fmt.Printf("Scanning image %s in job %s\n", image, jobName)
		if err != nil {
			fmt.Printf("Error %v", err)
		}
	}
	return nil
}

func getImage(runID int, imageName string, r *http.Request) (*Image, error) {
	var targets []Target
	clientset := getClientSet()
	decoder := json.NewDecoder(r.Body)
	if err := decoder.Decode(&targets); err != nil {
		return nil, fmt.Errorf("Invalid request payload")
	}
	defer r.Body.Close()

	pods, err := getPodsByImageName(imageName, clientset)
	if err != nil {
		return nil, fmt.Errorf("Could not get pods by image")
	}

	image := Image{
		Name:    imageName,
		Pods:    pods,
		Targets: targets,
	}
	if len(targets) <= 0 {
		bodyBytes, err := ioutil.ReadAll(r.Body)
		if err == nil {
			log.Printf("empty body: %s \n", string(bodyBytes))
		} else {
			log.Printf("cannot read body %v \n", err)
		}
	}

	return &image, nil
}

func getUniqueImagesFromPods(clientset *kubernetes.Clientset) ([]string, error) {
	pods, err := getPods(clientset)
	if err != nil {
		return nil, err
	}
	return getUniqueImages(pods), nil
}

func getPods(clientset *kubernetes.Clientset) ([]v1.Pod, error) {
	pods, err := clientset.CoreV1().Pods("").List(metav1.ListOptions{})
	return pods.Items, err
}

func getPodsByImageName(image string, clientset *kubernetes.Clientset) ([]Pod, error) {
	k8sPods, err := getPods(clientset)
	if err != nil {
		return nil, err
	}
	pods := []Pod{}
	for _, pod := range k8sPods {
		if pod.Status.Phase != v1.PodRunning {
			// only running images - should include jobs run since last get
			continue
		}

		add := false
		for _, container := range pod.Spec.Containers {
			if container.Image == image {
				add = true
				break
			}
		}
		if !add {
			for _, container := range pod.Spec.InitContainers {
				if container.Image == image {
					add = true
					break
				}
			}
		}
		if add {
			pods = append(pods, Pod{
				Name:      pod.GetName(),
				Namespace: pod.GetNamespace(),
			})
		}
	}
	return pods, nil
}

func getUniqueImages(pods []v1.Pod) []string {
	imagesExist := map[string]bool{}
	images := []string{}
	for _, pod := range pods {
		if pod.Status.Phase != v1.PodRunning {
			// only running images - should include jobs run since last get
			continue
		}

		for _, container := range pod.Spec.Containers {
			if !imagesExist[container.Image] {
				imagesExist[container.Image] = true
				images = append(images, container.Image)
			}
		}
		for _, container := range pod.Spec.InitContainers {
			if !imagesExist[container.Image] {
				imagesExist[container.Image] = true
				images = append(images, container.Image)
			}
		}
	}
	sort.Strings(images)
	return images
}

func respondWithError(w http.ResponseWriter, code int, message string) {
	respondWithJSON(w, code, map[string]string{"error": message})
}

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) {
	response, _ := json.Marshal(payload)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(response)
}
