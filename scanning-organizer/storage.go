package main

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"sync"
	"time"
)

// SQLClient used to perform sql queries
type SQLClient struct {
	Server   string
	Port     int
	Database string
	UserID   string
	Password string
	db       *sql.DB
}

// NewSQLClient create sqlclient and setup the db connection
func NewSQLClient(server, database string, port int, userID, password string) SQLClient {
	sqlClient := SQLClient{
		Server:   server,
		Database: database,
		Port:     port,
		UserID:   userID,
		Password: password,
	}
	sqlClient.db = sqlClient.setupDBConnection()
	return sqlClient
}

// CreateNewRun creates a new run and returns the run id
func (sqlClient SQLClient) CreateNewRun(measureTime time.Time) (int, error) {
	tsql := `INSERT INTO vulnerability.runs (measured_time_utc) 
	VALUES (@measuredTimeUTC); select convert(bigint, SCOPE_IDENTITY());`
	return sqlClient.execSQL(tsql,
		sql.Named("measuredTimeUTC", measureTime))
}

func (sqlClient SQLClient) saveTarget(runID int, image string, target *Target) error {
	tsql := `INSERT INTO vulnerability.images (name, run_id) 
	VALUES (@imageName, @runID); select convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save image")
	imageID, err := sqlClient.execSQL(tsql, sql.Named("imageName", image), sql.Named("runID", runID))
	if err != nil {
		return err
	}

	var wg sync.WaitGroup
	var saveVulErr error
	var savePodErr error
	wg.Add(2)
	go func() {
		saveVulErr = sqlClient.saveVulnerabilities(target.Target, imageID, target.Vulnerabilities)
		wg.Done()
	}()

	go func() {
		savePodErr = sqlClient.savePods(imageID, target.Pods)
		wg.Done()
	}()
	wg.Wait()

	if savePodErr != nil {
		return fmt.Errorf("Failed to save pod %v", savePodErr)
	}
	if saveVulErr != nil {
		return fmt.Errorf("Failed to save vulnerabilities %v", saveVulErr)
	}

	return nil
}

func (sqlClient SQLClient) savePods(imageID int, pods []Pod) error {
	tsql := `INSERT INTO vulnerability.pods (name, namespace, image_id) 
	VALUES (@name, @namespace, @imageID);select convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save pods")
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, pod := range pods {
		row := stmt.QueryRowContext(ctx,
			sql.Named("name", pod.Name),
			sql.Named("namespace", pod.Namespace),
			sql.Named("imageID", imageID))

		var newID int
		err = row.Scan(&newID)
		if err != nil {
			return fmt.Errorf("Failed to insert pod %v", err)
		}
	}
	return nil
}

func (sqlClient SQLClient) saveVulnerabilities(target string, imageID int, vulnerabilities []Vulnerability) error {
	tsql := `INSERT INTO vulnerability.vulnerabilties (target, cve_vulnerability_id, pkg_name, installed_version, layer_id, title, description, severity, image_id) 
	VALUES (@target, @cveVulID, @pkgName, @installedVersion, @layerID, @title, @description, @severity, @imageID); select convert(bigint, SCOPE_IDENTITY());`

	fmt.Printf("Save vulnerabilities")
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return err
	}
	defer stmt.Close()

	for _, vul := range vulnerabilities {
		row := stmt.QueryRowContext(ctx, sql.Named("target", target),
			sql.Named("cveVulID", vul.VulnerabilityID),
			sql.Named("pkgName", vul.PkgName),
			sql.Named("installedVersion", vul.InstalledVersion),
			sql.Named("layerID", vul.LayerID),
			sql.Named("title", vul.Title),
			sql.Named("description", vul.Description),
			sql.Named("severity", vul.Severity),
			sql.Named("imageID", imageID))

		var newID int
		err = row.Scan(&newID)

		if err != nil {
			return fmt.Errorf("Failed to insert vulnerability %v", err)
		}
	}
	return nil
}

// Close the underlying db connection
func (sqlClient SQLClient) Close() {
	sqlClient.db.Close()
}

// SetupDBConnection sets up db connection
func (sqlClient SQLClient) setupDBConnection() *sql.DB {
	// Build connection string
	connString := fmt.Sprintf("server=%s;user id=%s;password=%s;port=%d;database=%s;",
		sqlClient.Server, sqlClient.UserID, sqlClient.Password, sqlClient.Port, sqlClient.Database)

	var err error

	// Create connection pool
	db, err := sql.Open("sqlserver", connString)
	if err != nil {
		log.Fatal("Error creating connection pool: ", err.Error())
	}
	ctx := context.Background()
	err = db.PingContext(ctx)
	if err != nil {
		log.Fatal(err.Error())
	}
	fmt.Printf("Connected!\n")
	return db
}

func (sqlClient SQLClient) execSQL(tsql string, args ...interface{}) (int, error) {
	ctx, err := sqlClient.verifyConnection()
	if err != nil {
		return -1, err
	}

	stmt, err := sqlClient.db.Prepare(tsql)
	if err != nil {
		return -1, err
	}
	defer stmt.Close()

	row := stmt.QueryRowContext(ctx, args...)
	var newID int
	err = row.Scan(&newID)
	if err != nil {
		return -1, err
	}

	return newID, nil
}

func (sqlClient SQLClient) verifyConnection() (context.Context, error) {
	ctx := context.Background()
	var err error

	if sqlClient.db == nil {
		err = errors.New("CreateRun: db is null")
		return ctx, err
	}

	// Check if database is alive.
	err = sqlClient.db.PingContext(ctx)
	if err != nil {
		return ctx, err
	}
	return ctx, nil
}
