const azure = require("azure-storage");
const crypto = require("crypto");

// one table for each image:tag
// delete table on each test
// partition key = Target
// rowkey = VulnerabilityID

exports.vulnerabilities = () => {
  const imageTableName = "images";
  const imagePartitionKey = "reftable";
  const vulPartitionKey = "all";

  const bootstrap = () => {
    const tableService = azure.createTableService();
    tableService.createTableIfNotExists(imageTableName, function (error) {
      if (error) {
        throw error;
      }
    });
  };

  const getImages = (callback) => {
    var tableService = azure.createTableService();
    var query = new azure.TableQuery().where(
      "PartitionKey eq ?",
      imagePartitionKey
    );

    tableService.queryEntities(imageTableName, query, null, function (
      error,
      result
    ) {
      if (!error) {
        const images = result.entries.map((entity) => entityToImage(entity));
        callback(images);
      } else {
        callback(null, error);
      }
    });
  };

  const deleteAllImagesAndVulnerabilities = callback => {
    var tableService = azure.createTableService();
    getImages(images => {
      images.forEach(image => {
        deleteVulnerabilityByImage(image.Image, ()=> {});
        const entity = imageToEntity(image);
        tableService.deleteEntity(imageTableName, entity, function (error) {
          if (error) {
            console.log(error);
          }
        });
      })
      callback();
    })
  }

  const getVulnerabilitiesByImage = (image, callback) => {
    getEntitiesByImage(image, (entities, error) => {
      callback(entitiesToVulnerabilies(image, entities), error);
    });
  };

  const getEntitiesByImage = (image, callback) => {
    const tableService = azure.createTableService();
    const query = new azure.TableQuery().where(
      "PartitionKey eq ?",
      vulPartitionKey
    );
    const tableName = imageNameToTableName(image);

    tableService.queryEntities(tableName, query, null, function (
      error,
      result
    ) {
      if (!error) {
        callback(result.entries);
      } else {
        console.log(error);
        callback([], error);
      }
    });
  };

  const getVulnerabilityById = (image, id, callback) => {
    var tableService = azure.createTableService();
    tableService.retrieveEntity(tableName, image, id, function (error, result) {
      if (!error) {
        callback(entityToVul(result));
      } else {
        callback(null, error);
      }
    });
  };

  const saveVulnerabilities = vulnerabilities => {
    const tableService = azure.createTableService();
    const image = vulnerabilities[0].Image;
    const tableName = imageNameToTableName(image);

    tableService.createTableIfNotExists(tableName, function (error) {
      if (error) {
        throw error;
      }
      const imageEntity = vulnerabilitiesToImageEntity(vulnerabilities);
      vulnerabilities.forEach((vul) => saveVulnerability(vul, tableService));
      tableService.insertOrReplaceEntity(imageTableName, imageEntity, function (
        error
      ) {
        if (error) {
          console.log(error);
        }
      });
    });
  };

  const saveVulnerability = (vul, tableService) => {
    if (!tableService) {
      tableService = azure.createTableService();
    }
    const tableName = imageNameToTableName(vul.Image);
    const entities = vulnerabilitiesToEntity(vul);
    entities.forEach((entity) =>
      tableService.insertOrReplaceEntity(tableName, entity, function (error) {
        if (error) {
          console.log(error);
        }
      })
    );
  };

  const deleteVulnerabilityByImage = (image, callback) => {
    const tableName = imageNameToTableName(image);
    const tableService = azure.createTableService();
    tableService.deleteTableIfExists(tableName, (error) => {
      if (error) {
        console.log(error);
      }
      callback();
    });
  };

  const imageToEntity = image => {
    const entGen = azure.TableUtilities.entityGenerator;
    const rowKey = imageNameToTableName(image.Image);

    return {
      PartitionKey: entGen.String(imagePartitionKey),
      RowKey: entGen.String(rowKey),
      Image: entGen.String(image.Image),
      Critical: entGen.Int32(image.Critical),
      High: entGen.Int32(image.High),
      Medium: entGen.Int32(image.Medium),
      Low: entGen.Int32(image.Low),
      Unknown: entGen.Int32(image.Unknown),
    };
  }

  const vulnerabilitiesToImageEntity = (vulnerabilities) => {
    const entGen = azure.TableUtilities.entityGenerator;
    const image = vulnerabilities[0].Image;
    const rowKey = imageNameToTableName(image);
    return {
      PartitionKey: entGen.String(imagePartitionKey),
      RowKey: entGen.String(rowKey),
      Image: entGen.String(image),
      Critical: entGen.Int32(
        getNrOfVulerabilitiesBySeverity(vulnerabilities, "CRITICAL")
      ),
      High: entGen.Int32(
        getNrOfVulerabilitiesBySeverity(vulnerabilities, "HIGH")
      ),
      Medium: entGen.Int32(
        getNrOfVulerabilitiesBySeverity(vulnerabilities, "MEDIUM")
      ),
      Low: entGen.Int32(
        getNrOfVulerabilitiesBySeverity(vulnerabilities, "LOW")
      ),
      Unknown: entGen.Int32(
        getNrOfVulerabilitiesBySeverity(vulnerabilities, "UNKNOWN")
      ),
    };
  };

  const getNrOfVulerabilitiesBySeverity = (vulnerabilities, severity) => {
    const nr = vulnerabilities.reduce(
      (prev, curr) =>
        prev +
        curr.Vulnerabilities.filter((v) => v.Severity === severity).length,
      0
    );
    console.log(nr);
    return nr;
  };

  const imageNameToTableName = (imageName) => {
    var hash = crypto.createHash("md5").update(imageName).digest("hex");
    return "tbl" + hash;
  };

  const entityToImage = (entity) => {
    return {
      Image: entity.Image ? entity.Image._ : "",
      Critical: entity.Critical ? entity.Critical._ : 0,
      High: entity.High ? entity.High._ : 0,
      Medium: entity.Medium ? entity.Medium._ : 0,
      Low: entity.Low ? entity.Low._ : 0,
      Unknown: entity.Unknown ? entity.Unknown._ : 0,
    };
  };

  const vulnerabilitiesToEntity = (vuls) => {
    const entGen = azure.TableUtilities.entityGenerator;

    return vuls.Vulnerabilities.map((vul) => {
      const rowKey =
        "key" +
        crypto
          .createHash("md5")
          .update(vul.VulnerabilityID + vuls.Target)
          .digest("hex");
      return {
        PartitionKey: entGen.String(vulPartitionKey),
        RowKey: entGen.String(rowKey),
        Image: entGen.String(vuls.Image),
        Target: entGen.String(vuls.Target),
        VulnerabilityID: entGen.String(vul.VulnerabilityID),
        PkgName: entGen.String(vul.PkgName),
        InstalledVersion: entGen.String(vul.InstalledVersion),
        FixedVersion: entGen.String(vul.FixedVersion),
        Title: entGen.String(vul.Title),
        Description: entGen.String(vul.Description),
        Severity: entGen.String(vul.Severity),
        References: entGen.String(
          vul.References ? JSON.stringify(vul.References) : "[]"
        ),
      };
    });
  };

  const entitiesToVulnerabilies = (image, entities) => {
    if (!entities || entities.length <= 0) {
      return {
        Image: image,
      };
    }
    const target = entities[0].Target._;

    return {
      Image: image,
      Target: target,
      Vulnerabilities: entities.map((entity) => {
        return {
          VulnerabilityID: entity.VulnerabilityID
            ? entity.VulnerabilityID._
            : "",
          PkgName: entity.PkgName ? entity.PkgName._ : "",
          InstalledVersion: entity.InstalledVersion
            ? entity.InstalledVersion._
            : "",
          FixedVersion: entity.FixedVersion ? entity.FixedVersion._ : "",
          Title: entity.Title ? entity.Title._ : "",
          Description: entity.Description ? entity.Description._ : "",
          Severity: entity.Severity ? entity.Severity._ : "",
          References: entity.References ? JSON.parse(entity.References._) : [],
        };
      }),
    };
  };

  return {
    bootstrap,
    getImages,
    getVulnerabilitiesByImage,
    getVulnerabilityById,
    saveVulnerability,
    saveVulnerabilities,
    deleteAllImagesAndVulnerabilities,
  };
};
